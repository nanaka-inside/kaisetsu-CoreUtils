.. raw:: latex

   \clearpage


はじめに
========

筆者まえがき
-------------

「情報というのは面白いもので、こちらから探しにいかないとないのと同じで、ゲームなどでも攻略に行き詰まったりして、ネットでWikiを調べてみたり、攻略本を探してようやく出てくるという性質でして、人間、必要に駆られないと、なかなか新しい情報を得ようとしない [#core-bukkyo]_ ものです。」 [#coreutils-monodesu]_

.. [#core-bukkyo] なかなか新しい情報を得ようとしない：新しい情報が得られる便利な仕組みはいくつもあるものの、そういうツールが増えれば増えるほど「自分にとって都合のよい新しい情報」しか目に入らなくなるのが人間の愛おしさである。
.. [#coreutils-monodesu] 蝉丸P (2012). 蝉丸Pのつれづれ仏教講座 株式会社エンターブレイン p.263


ごあいさつ
----------
筆者の@tboffice [#twitter-tboffice]_ と申します。この本は、GNU Coreutils [#coreutils-url]_ のマニュアルをひと通り眺めてみて、解説をしてみようというコンセプトの本に書かれた本です。
弊サークル・第7開発セクションが発行してきた同人誌「ななかInside PRESS」の2号と3号にまたがって掲載された「Coreutils大全」という連載を一冊の本にまとめました。

なぜ今、Coreutilsなのか。

linuxのコンソールでお仕事をしていると、シェルスクリプトで楽をしようとします。
楽をするため、コマンドを調べていたところ、Coreutilsのマニュアルにたどり着きました。
気づけば、Coreutilsのマニュアルを読んで、コマンドの実行方法や、知らなかったコマンドや、いままで使ったことがないオプションを見つけていました。

.. [#twitter-tboffice] https://twitter.com/tboffice
.. [#coreutils-url] http://www.gnu.org/software/coreutils/
.. [#core-sed] coreutilsに含まれないコマンド(sedとか)がばんばん出てくるしどうしてこうなった

たとえば、

* 「 ``cat`` をたんどくでじっこうしたら どうなるです？」
* 「ふぁいるを ``pr | pr`` したらどうなるです？」「べとべとです？」
* 「 ``tail -f`` と ``tailf`` はどこがちがうです？」
* 「だーくふれいむますたー！」(指を指して)「あのころのきおくをけすにはどうやるです？」
* 「ばいなりでーたおいしいです」 [#core-yousei]_ 
* 「イエッス！アスミス！」
* 「ここはどこ？わたしはだあれ？」
* 「せんせい！そいんすうぶんかいがしたいです！」 [#core-yousei]_ 

.. [#core-yousei] どこぞの妖精さんをお借りしました。扱いにくいキャラクターですね。文章にするとかどくせいがひじょうにわるいです？

普段linuxを使っているけど、このコマンド知らなかった、こんな使い方ができるのか、という発見が一つでもあれば幸いです。
筆者がよく使うコマンドや Tips も載せました。それでは、深遠なるCoreutilsの世界へようこそ。


注意
----
Coreutilsのバージョンで使えないコマンドやオプションがあります。
また、筆者が検証した環境は さくらのVPS CentOS 5.7 と value-server [#vs]_ と amazon EC2 2014.03 のマイクロインスタンスです。
コマンドのサンプルは実際に実行して試していますが、実際に使うときは誰にも迷惑をかけないところで検証して、コマンドの意味を分かった上で使って下さい。

.. [#vs] 安価な共用サーバを使っていました。どういうハードウエア使ってるのかなーと思って申し込んでちょっと使っていました

この本では、Coreutilsのマニュアルの冗長な部分はできるだけ端折って、面白そうなところや、実践的な部分を取り扱っています。
もし時間があるようであれば、Coreutilsのマニュアルを上から下まで読んでみてください。新たな発見があると思います。
特に考えて文章を書いていなかったため、Coreutilsにないコマンドも載っていることもあります [#okonano]_ 。

本文中の「原文」はCoreutilsのマニュアルのことを指します。

.. [#okonano] 怒らないよね？おこなの？(やめろってば


そもそもCoreutilsとは
---------------------

「コアユーティルズ」と読みます。文字に落としてみるとダサいですね。
まあ、そのへんは置いといて、Coreutilsとは、 ``ls`` や ``cat`` など、linuxでは欠かせないコマンドをまとめたパッケージです。
Coreutilsが登場する前は、Fileutils, Shellutils, Textutilsというutilsがありました。
Coreutilsは、それらを統合したものです。ChangeLogをみたところ、一番古い日付は2002-07-01でした。
おそらくそのころに統合されたのでしょう。メジャーバージョンは2003年4月にバージョン5として登場しました。
2014年4月現在、8.22がリリース [#release]_ されています。


.. [#release] 2013-12-13にリリースバージョンがついただけで、結構な頻度でアップデートかかってるように見えます


本稿の構成
----------
最初にCoreutilsパッケージのコマンドに共通のオプションを解説し、Coreutilsのマニュアル [#coreutils-manual]_ の通りにコマンドを並べています。

.. [#coreutils-manual] http://www.gnu.org/software/coreutils/manual/

.. contents:: これは目次です
   :depth: 3

.. raw:: latex

   \tableofcontents
   \phantomsection\label{index::doc}


イントロダクション
==================

ここから、Coreutilsのマニュアルに入ります。Coreutilsのマニュアルの第1章は、「Introduction」から始まっています。少し読んでみましょう。

Coreutilsのマニュアルは、未確認で進行形じゃなかった、作成途中です。
まさに作っているところで、初心者向けに基本的な概念は説明してないよ！興味があれば改善していってね。
あと、バグを見つけたら ``bug-coreutils@gnu.org`` に送ってね。そのとき、再現環境も一緒に送ってね！ [#senjin-namae]_ だそうです。

.. [#senjin-namae] あとは先人たちの名前が書かれています


共通のオプション
=================
Coreutilsのコマンドに共通するオプションです。


``--help``
----------
たとえば ``ls`` のコマンドのオプションを調べたいとき


.. code-block:: sh

   $ ls --help


簡易ヘルプはこのオプションをつかえば問題☆解決。え？問題が解決しない？そんなときはこのようなコマンドを打ってください。


.. code-block:: sh

   $ man ls
   $ info coreutils ls


infoコマンドを打った後は、Emacsのキーバインドなのでそこさえ気をつければinfoコマンドは良いコマンドだと思いますよ（白目

``--version``
--------------
バージョンを表示します。

``--``
------

このオプションを打った後は、オプションが無効になります。
たとえば、こんなコマンドを打ったとき


.. code-block:: sh

   $ ls -l -- -l


-lというファイルあるいはディレクトリをls -lで表示します。

.. code-block:: sh
   
   $ mkdir -- -l


とやると、 ``-l`` というディレクトリが出来ます。touchでも同様。

``-``
-----

ただのハイフンです。

オプションじゃないよ！ [#haifn]_ 。オプションに見えるだけだよ？ホントだよ？すたんだーどいんぷっとを待つ記号だよ！
受け取った結果はコマンドがよろしく処理するよ！たとえばこんな感じだよ！あとで出てくるから覚えておいてね！

.. [#haifn] と、マニュアルに書いてあります

.. code-block:: sh

   $ sort - 
   b # 打つべし
   a # 打つべし
   c # 打つべし
   Ctrl-d # ctrl押しながらdって打つと下記のように表示されるよ！
   a
   b
   c


ファイルまるまる出力系
======================

ファイルが高まる出力系 [#marumaru]_ のコマンドです。ファイルの意識を高めましょう [#file-takamaru]_ 。

.. [#marumaru] 原文では、Output of entire filesとなってます。高まるってなんだ？
.. [#file-takamaru] どうやるんだろう

cat
---

情報系の講義があると、linuxの基礎としてほぼ間違いなく出てくるコマンドではないでしょうか。
ファイルを引数にとると、そのファイルの中身を表示しれくれるコマンドです [#cata]_ 。
fileというファイルの中身を出力するときにはこうします。

.. [#cata] 説明が足りないと気づいた方は正しいです。coreutilsのマニュアルの通りの説明は後ほど

.. code-block:: sh

   $ cat file


次に、マニュアルにあるオプションの読み方を説明します。マニュアルには


:: 

   cat [option] [file]...


とあります [#catb]_ 。

.. [#catb] ほかのコマンドのマニュアルもほぼ同様に書かれています


``[]``
   この括弧で囲まれている部分は省略可能です
``...``
   この記号は引数がいくつでもいいよって言ってます

つまりこんな感じでコマンドを作ることが出来ます。

.. code-block:: sh

   $ cat -A -n hogefile fugafile piyofile


主なオプションの説明をします。

-E
   行末がどこまで入ってるか分からないから表示して

-n 
   行数を付けて

-T
   タブ文字も表示して欲しいなぁ

-v 
   改行文字も表示して欲しいなー

-A
   -vETと同じ。改行文字、行末文字、タブも表示します

オプションのFILE部分に - を入れると標準入力になります。fとgというファイルがあって、

.. code-block:: sh

   cat f - g 

このようにコマンドが実行されたときは、fの内容を表示、標準入力の内容表示、ctrl-d(入力の終わり)を押したらgの内容が表示されます。
``cat`` 単独で打ったときは --- マニュアル通りの説明をすると、「ファイルまたは標準入力を標準出力にコピーする」 [#catm]_ です。
引数が指定されていないときは標準入力になります。標準入力と標準出力を体感してください [#cat-ji]_ 。

.. [#catm] cat copies each file (‘-’ means standard input), or standard input if none are given, to standard output. 
.. [#cat-ji] 実際に打ってみよう!!

tac
---
linuxの講義があっても、ほぼ出てこないコマンドです。むしろこういう先人たちが作った無駄なコマンドこそ美学だと思うのです [#tachoge]_ 。
さて、catのあとのtac。お察しの通りです。早速、実行してみましょう。ファイルを作るのが面倒なのでechoしてます。


.. code-block:: sh

   $ echo -e "a\nb\nc" | tac
   c
   b
   a


はい、ファイルの内容を上下逆に出します。1行分の文字の並びを逆にするには、 rev コマンドを使ってください。
誰得魔方陣の例。

.. code-block:: sh

   $ echo -e "2 9 4\n7 5 3\n6 1 8" | tac | rev 


単語単位で逆にするには、

.. code-block:: sh

   $ tac -r -s '[^a-zA-z0-9\-]' file


revと同じ効果をtacでやるには下記 [#taca]_ 。ただし日本語の2バイト文字列も逆にするので化けます。おちゃめさんですね（何


.. code-block:: sh

   $ tac -r -s '.\|' myfile

.. [#taca] 単語単位で逆にする例、とrevの効果の例は下記に載っていました。http://bit.ly/SwZTt4
.. [#tachoge] 使い方によっては全く無駄ではないのです。コマンドを適所に活かすのです。偉い人には以下略


nl
---
行番号を振ってくれるコマンド。単に実行した場合はこんな感じです。

.. code-block:: sh

   $ nl /etc/issue
   1  CentOS release 5.7 (Final)
   2  Kernel \r on an \m
    

デフォルトだと、空行には番号がつかないです。なお、 ``cat -b file`` と同じです。
オプションに ``-b a`` を付けると空行でも行番号がつきます。いろいろオプションがあるので値を変更してみてください。

.. code-block:: sh

  $ echo -e "hoge\n\nfuga\npiyo" | nl -b a -n rz -s " hoge: " -v 3 -w 3
    003 hoge: hoge
    004 hoge: 
    005 hoge: fuga
    006 hoge: piyo


od
---
ファイルを8進数や16進数で表示するコマンド。デフォルトでは8進数で表示。
なんとなく ``xxd`` を使ってしまって、出番のないコマンドのような...

.. code-block:: sh

  $ od /etc/issue
  0000000 062503 072156 051517 071040 066145 060545 062563 032440
  0000020 033456 024040 064506 060556 024554 045412 071145 062556
  0000040 020154 071134 067440 020156 067141 056040 005155 000012
  0000057


base64
------
データを印刷できる形式に変換するコマンド、とマニュアルには書いてあります。
RFC 4648 [#rfc4648]_ に則ってデータを変換するコマンドで、133%データが大きくなります。デコードも出来ます。

.. code-block:: sh

   $ base64 /etc/issue | base64 --decode -i
   CentOS release 5.7 (Final)
   Kernel \r on an \m

.. [#rfc4648] http://tools.ietf.org/html/rfc4648


体裁を整える系
==============

fmt
---
テキストファイルの文字を適当に折り返してくれるコマンド。デフォルトだと75文字で折り返します。すでに改行されてしまっているテキストファイルでもなんとかしてくれます [#fmta]_ 。

.. [#fmta] wikipediaのサンプルが易しいです。http://en.wikipedia.org/wiki/Fmt

numfmt
------
比較的新しいコマンドです [#numfmt-date]_ 。4Gを4,000,000に変換してくれます。例をいくつか拾ってみましょう。詳しいことはマニュアルを読みましょう。

.. code-block:: sh
   
   $ numfmt --from=auto 1Mi
   1048576

   $ numfmt --to=si 500000
   500K

   # Third field (file size) will be shown in SI representation
   $ ls -log | numfmt --field 3 --header --to=si | head -n4
   -rw-r--r--  1     94K Aug 23  2011 ABOUT-NLS
   -rw-r--r--  1    3.7K Jan  7 16:15 AUTHORS
   -rw-r--r--  1     36K Jun  1  2011 COPYING
   -rw-r--r--  1       0 Jan  7 15:15 ChangeLog

   $ LC_ALL=en_US.utf8 numfmt --from=iec --grouping 2G
   2,147,483,648


.. [#numfmt-date] 2013年2月に追加

pr
---
印刷用にヘッダとフッタを自動的に追加してくれてくれるコマンド。RFCみたいな文章がすぐに出来るよ！プレーンテキストすばらしい！と筆者の脳内で大好評のコマンドです。お試しあれ。ただし使いどころは限定的です。
なお、 ``pr | pr`` するとヘッダとフッタが二重につくだけです。こんな感じです [#pra]_ 。

.. code-block:: sh

   $ cat /etc/issue | pr | pr | pr | head -n 20


   2014-04-17 18:58                                                1 ページ




   2014-04-17 18:58                                                1 ページ




   2014-04-17 18:58                                                1 ページ


   Amazon Linux AMI release 2014.03
   Kernel \r on an \m

.. [#pra] なぜ三重にしたし

fold
----
テキストファイルをぴったりの文字数で改行するコマンド。fmtは空気を読んで、単語をぶったぎらないようにしていますが、このコマンドは空気を読まずにぶった切ります。fmtの様な挙動をさせるには、-sをつけるとある程度空気を読んでくれます。fmtは引用符の中は改行しませんが、foldは改行します。


ファイルの一部を出力
====================

head
-----
ファイルの最初の10行を表示するコマンドです。
``-n 5`` で先頭5行を表示。 ``-c 10KB`` で先頭10キロバイトを表示。バイナリファイルでもOK [#head-tty]_ 。宗教上の理由でheadコマンドを打ちたくない人は、sed 10q と打ってください。
-n のあとにマイナス値を打つとどうなるでしょうか。環境にもよりますが...自分でやってみてください。

.. [#head-tty] 標準出力に出力して、端末が化けても知らないですよ

tail
-----
ファイルの最後の10行を表示するコマンド。サーバ管理者は毎日打っていると言っても過言ではないです。
-f オプションをつけることによって、ターゲットのファイルに対して追加された文字が出てきます。ちなみに複数のファイルを食わせることができるので、アクセスログファイルとアクセスエラーログファイルの両方を ``tail -f`` で表示することも可能。パイプでつないで特定の文字列だけ出力することも可能。

.. code-block:: sh
   
   tail -f access.log error.log | grep --color -E "(==|192.168)"


ログファイルから==または、192.168という文字列を抜き出しています [#taila]_ 。"=="というのは、やってみてのお楽しみ。

.. [#taila] ちなみにgrepの--colorオプションはこのURLで知りました。http://aerith.mydns.jp/regrets/2008/12/tail-color.html


tailコマンドといえば、tailfコマンドに触れないわけにはいかないでしょう。tail -f コマンドと同じような働きをする tailf コマンドがあります。
結論から言うと、最新のcoreutilsを使っているならどっちも変わりありません [#tailaa]_ 。どちらも inotify イベントを受け取って処理するようになっています。
もしも、対象のファイルが消えてしまうときは、ファイルを読み直す下記のオプションを使いましょう。

.. [#tailaa] coreutils version 7.5でinotifyに対応した模様です。ここを参照しました。http://dev.ariel-networks.com/Members/inoue/tailf/


.. code-block:: sh

   $ tail -F filename

なお、 ``tail -n +2 file`` とすると、fileファイルの1行目だけ削れます。mysqlコマンドに-eでSQLを打ち込むと一行目にカラム名でてくるじゃないですか、あれを削るときに使うんですよ [#tailb]_ 。
余談として、-r  オプションがあったのですが、coreutilsには実装されていません。tacコマンドを使ってください。

.. [#tailb] おい、やけに具体的だな

split
------
ファイルを分割するコマンドです。
書式は下記です。

.. code-block:: console

   split [option] [input [prefix]]

デフォルトで実行するとこんな感じになります。

.. code-block:: sh

   $ split hogefile
   $ ls 
   hogefile xaa  xab  xac  xad  xae  xaf  xag  xah  xai 

1000行ごとに1ファイルを、カレントディレクトリに生成します [#splita]_ 。xaa xab ... となっているのは、あとでcatすると元に戻る [#splitb]_ からです。100行ごとに分割してほしいとか、xxというファイル名いやだというときはこんな感じです。

.. [#splita] でかいサイズのファイルのときには注意。たくさんファイルができるよ！！
.. [#splitb] cat x* する。xの次はy,zと使っていく。最後どうなるのか実験だ！


.. code-block:: sh
   
   $ split -l 100 hogefile AA
   $ ls 
   hogefile AAaa  AAab  AAac  AAad  AAae  AAaf

-bオプションで任意のバイト数でsplitすることができます。分割しながら圧縮できる(filterに通す)というオプションもあります [#splitc]_ [#splitd]_ [#splite]_ [#splitf]_ [#splitg]_ 。

.. [#splitc] xz -dc BIG.xz | split -b200G --filter='xz > $FILE.xz' - big- (マニュアルより。big-aa.xz, big-ab.xzといったようにファイルが出来上がります)
.. [#splitd] ディスクの単価が安い現代に需要があるかどうか... 
.. [#splite] あるって!開発環境とかいつもディスク枯渇してるじゃん!!
.. [#splitf] 開発環境でsplitする用途があるか疑問だにゃあ
.. [#splitg] 脚注で会話するなよ

使いどころが非常に謎ですが、-nオプションの例を示します [#splitn]_ 。

.. [#splitn] [練習問題] 何をしているのか、マニュアルを読んで確認してみましょう

.. code-block:: sh
   
   $ seq 100 > k; split -nl/7/33 k
   20
   21
   22


csplit
-------
「ファイルを文脈ベースで分割する」コマンドです。端的には、特定の文字が出てきたらsplitするコマンドです。使いどころによっては非常に強力なコマンドです。書式は下記。

.. code-block:: sh

   csplit [option]... input pattern...


下記のようにすると、xx00に文字列を出力し、hogeという文字と遭遇したら、別のファイル(xx01)をつくって、そこに出力します。もとのファイルはそのまま残っています。xx01のファイル名の1行目に ``hoge`` という文字が含まれています [#csplist-x]_ 。

.. [#csplist-x] 長い文章をすぱっと二つに分割する時に便利。日本語文字列でもsplitできる。hoge文字列からのoffsetが使えるのがさらに便利

.. code-block:: sh 

   $ csplit hogedfile /hoge/

さてマニュアルを追ってみましょう。「ファイルがたくさんできるから、最初にディレクトリを作り、その中にcdしましょう」と書いてあります。

.. code-block:: sh 

   $ mkdir d && cd d

次に0または5で終わる文字にマッチしたら、そこでまた別のファイルを作ってそこに出力します。 ``{*}`` があるので、マッチしたぶんだけファイルが生成されます。出力されている数字は、それぞれのファイルのバイト数です。

.. code-block:: sh 

   $ seq 14 | csplit - '/[05]$/' '{*}'
   8
   10
   15
   $ ls
   xx00  xx01  xx02

ファイルの中身が、なんとなくどうなっているか分かったところでおわりです。


ファイルの要約系
================

wc
---
ファイルの行数を知るときによく出るコマンドです。wc -l が有名すぎて、wc単体の結果についてはmanを引かないと忘れてることが多いです。筆者も忘れています [#wca]_ 。
圧縮されているファイルの文字数を知りたいだけの時は、 ``bzcat foo.bz2 | wc -c`` などとするのがよさそう。

.. [#wca] デフォルトでは、行数、単語数、バイト数を出力するんですか？\\つまんねーこと聞くなよ／

-L オプションで、ファイルの中で一番長い行の長さが出ます。また、下記の例では、\*.c または \*.hファイルのリストから、1行の行数が一番長い行の文字列を表示します。

.. code-block:: sh

   find . -name '\*.[ch]' -print0 | wc -L --files0-from=- | tail -n1


sum
----
BSDのアルゴリズムで16bitのファイルのチェックサムと1024バイト単位のブロック数を表示するコマンド。
-sオプションでSyatem Vのアルゴリズムを使ってのチェックサムと、512バイト単位のブロック数を表示 [#suma]_ 。

.. [#suma] と、とくに引っ掛かりもなく書いてますが、筆者はBSDやらSystem Vは名前を聞いたことある程度の知識だったりします。BSDに関していえば、学生の頃netBSDで自宅サーバたててたくらいしか接点がないです


cksum
-----
ファイル名を引数に取ると、CRC [#cksum]_ のチェックサムを表示します。

.. [#chksum]_ 巡回冗長検査。Cyclic Redundancy Check のこと。詳しくはwikipdiaへ


md5sum
------
128bitのチェックサム(またはフィンガープリントまたはメッセージダイジェスト [#md5sumbb]_ )を計算します。リリースするバイナリと、本番でデプロイされているバイナリが一致しているかどうか確かめる時にたまに使います [#md5sum]_ 。

.. [#md5sumbb] この本を読んでいるのにフィンガープリントとメッセージダイジェストを知らないだと!?出直してこい!!と言われないように、知らない人は調べましょう
.. [#md5sum] 突然真面目にTipsだしてきたよこの筆者

md5sumが一致するかどうか確かめましょう [#md5sumb]_ 。

.. code-block:: sh

   $ touch a && md5sum a > a.sum
   $ md5sum -c a.sum
   a: OK

.. [#md5sumb] d41d8cd98f00b204e9800998ecf8427e という謎の文字列をググると191万件ヒットしました



sha系
-------

sha系と、sha2で始まるコマンドをまとめました。

sha1sum 
  SHA-1のダイジェストを計算します。md5sumより安全なダイジェストです。SHA-2にとってかわられて徐々に廃止すべき、とマニュアルに書かれています。

sha2系コマンド
  sha224sum, sha256sum, sha384sum, sha512sumというコマンドがあります。それぞれのビット長のSHAダイジェストを計算します。オプションは、md5sumと同じです。


仕分系
============================
ファイルの中身をソート(仕分)するコマンド群です。

sort
-----
ファイル中身をソートするコマンド...と書き始めたかったのですが、それ以外にも機能があります。
ファイルを、ソート、マージ、または比較し、表示します。実は3つのモードを持っていて、ソートするモード、マージするモード、ファイルがソートされているかチェックするモードがあります [#sort1]_ 。

.. [#sort1] マニュアルをちょっと意訳してます

チェックオプションのサンプルは下記のようになります。

.. code-block:: sh

   $ seq 12 > k; sort -c k
   sort: k:10: disorder: 10


マージのオプションはこんな感じです。あらかじめソート済みのファイルを流し込んでやるとソートしてくれます。そのため、seqコマンドであらかじめ連続したデータを作っておきます。せっかくなのでheadコマンドで表示してみました。

.. code-block:: sh

   $ seq 0 2 10 > a
   $ seq 1 2 10 > b
   $ head a b 
   ==> a <==
   0
   2
   4
   6
   8
   10

   ==> b <==
   1
   3
   5
   7
   9

次に、こんなソートを試します。

.. code-block:: sh

   $ sort a b
   0
   1
   10
   2
   3
   4
   5
   6
   7
   8
   9

10は後ろに持ってきたいですよね。そんなときには、-n [#sort-n]_ または-g [#sort-g]_ または-h [#sort-h]_ を付けて下さい。

.. [#sort-n] マイナスがついている数値でもソートしてくれます
.. [#sort-g] マイナスやプラスの記号がついていてもソートしてくれます
.. [#sort-h] echo -e "+4\\n1G\\n30K\\n-1" | sort -h などと打ってもK,Gを認識してソートしてくれます。誰得

-uで重複をはじいてくれたり、-rで逆順にしたり、csvデータの特定の数値だけを基準にして並べてくれたり、IPアドレスを小さい順に並べるといったことも可能です。あとはマニュアルとにらめっこして下さい [#sort-tr]_ 。

.. [#sort-tr] coreutilsのコードを眺めると分かるんですが、lsに次いでコードのサイズが大きいです

shuf
-----
ファイルをshuffleしてくれます [#shuf-1]_ 。
もしseqをつかって数字をランダムに出したいときはいったん思いとどまって、下記のようにして下さい [#shuf-2]_ 。

.. code-block:: sh

   $ shuf -i 1-4                                                                      
   3
   1
   2
   4

同じファイルを共有していれば、同じ結果が返ってきます。つまり、さっき作った k というファイルを使って、あなたと同じランダムな結果を実現してみましょう [#shuf-ran]_ [#shuf-sort]_ [#shuf-yodan]_ 。

.. code-block:: sh
   
   $ shuf --random-source=k -e hoge fuga piyo choi
   fuga
   hoge
   piyo
   choi

.. [#shuf-1] CentOS5.7な環境でコマンドうったら出てこない!それもそのはず、CentOSのcoreutilsのバージョンが古いのでした(5.97)。バージョン6.4から新しく加入したコマンドです。amazon ec2には 8.4 が入ってました
.. [#shuf-2] 当然、この通りに出てくるわけではありません。--random-source=FILE というオプションもあるのでこだわりたい方はこだわれます
.. [#shuf-ran] これを人はランダム、と呼ぶのだろうか。謎である
.. [#shuf-sort] sortにも同じオプションがあります。sortのオプション ``-R`` ``--random-sort`` ``--sort=random`` を見てみてください
.. [#shuf-yodan] マニュアルには、 ``-r`` または ``--repeat`` というオプションがあります。これを使うと、指定した回数だけ繰り返すので、``$ shuf -r -n 50 -e Head Tail`` ができます。誰得。なお、Coreutils 8.21では未実装でした

uniq
----
ソート済みのファイルを引数に取ると、重複行を取り除いたデータを書き出してくれます [#uniq-1]_ 。
sortにも-uオプションがあり、uniqコマンドを単体で打ったときと同じようなことをやってくれます。
よく使うパティーン [#uniq-2]_ 


.. code-block:: sh

   cat file | sort | uniq -c | sort -nr | head

.. [#uniq-1] テストに出るぞー
.. [#uniq-2] fileに出現した同じ文字列を出現順にランキング表示です。サーバ管理者でこれが出来なかったら落第だ！

comm
----
2つのファイルを比較して、片方にしかないデータ、両方にしかないデータなどを出力してくれます [#comm-1]_ 。
ベン図を書いて、きちんと整理してデータの集計に当たりましょう。実行結果が独特なのでサンプルを載せます。

.. code-block:: sh

   $ seq 1 3 9 > q
   $ seq 1 2 9 > w
   $ head q w                                                                         
   ==> q <==
   1
   4
   7

   ==> w <==
   1
   3
   5
   7
   9
   $ comm q w
                  1
           3
     4
           5
                  7
           9

.. [#comm-1] 通話のアプリじゃないですよ。念のため

カラムが3つあります。単独でカラムを取り出したい場合は、 ``-1`` , ``-2`` , ``-3`` というオプションがあるのでこれを使います。

ptx
----
日本語マニュアルによると、「ファイルの内容の整列した索引を生成する」「入力ファイルに含まれる単語の索引を並べ替え、前後を含めて出力します。」 [#ptxa]_ とありますが、使いどころが分からないッ!

.. [#ptxa] http://linuxjm.sourceforge.jp/html/GNU_coreutils/man1/ptx.1.html

tsort
-----
前後関係を与えると、その順にソートしてくれます [#tsorta]_ 。

.. [#tsorta] マニュアルによると「有向グラフのトポロジカルなソートを行う」と書かれていて、ちょっと何言ってるかよく分からないです

実行例を見た方が早いです。 ``hoge`` は ``fuga`` の前にあるといった組を用意してtsortに食わせると順番に並び替えます。

.. code-block:: sh

   $ cat text
   hoge fuga
   fuga piyo
   foo bar
   bar baz
   baz hoge

   $ tsort text
   foo
   bar
   baz
   hoge
   fuga
   piyo


テーブルの欄操作
================

cut
---
ファイルを垂直に切り出します。オプションが必須のコマンドです。
たとえば今月の日曜日の日にちだけ切り出してみましょう [#cal]_ 。-c1-2とすると、1から2文字目までが縦方向に切り取られて表示されます。

.. [#cal]  ``cal`` コマンドは今月のカレンダーを表示しれくれます

.. code-block:: sh

   $ cal | cut -c1-2
   Su
     
    4
   11
   18
   25

csvデータから特定のカラムだけ切り出せます。tsortで出てきたtextファイルに対して2カラム目だけ表示させてみましょう。文字の区切りはスペース1個(-d" ") 、2つめのカラム目を表示(-f2)するオプションを付けます [#cut-awk]_ 。

.. [#cut-awk] [練習問題] awkでも同じコマンドを作ってみましょう

.. code-block:: sh
   
   % cut -f2 -d" " text                                                                
   fuga
   piyo
   bar
   baz
   hoge



paste
-----
ファイルの1行1行を横にひっつけていきます。具体例はマニュアルに書いてあるので読んで下さい。え？読むのがめんどくさい？しょうがないにゃあ。

.. code-block:: sh
   
   $ cat num2
   1
   2
   $ cat let3
   a
   b
   c
   $ paste num2 let3
   1       a
   2       b
           c

``-s`` (serial)オプションを付けるとこんな感じ。

.. code-block:: sh

   $ paste -s num2 let3
   1       2
   a       b       c


join
----
ファイルを横にjoinします。pasteと同じように見えるかもしれませんが、1カラム目が共通の2つのファイルに対してよしなにjoinしてくれます。

.. code-block:: sh

   $ cat c 
   00:00 100
   00:01 200
   00:02 300
   $ cat d 
   00:00 150
   00:01 250
   00:02 250
   $ join c d
   00:00 100 150
   00:01 200 250
   00:02 300 250

とあるサイトのバーチャルホスト別のアクセス数を1分ごとに取るスクリプトを書いて、csvで出してみたりするのがお気に入り。hoge-access.min.logはさっきでてきたファイル c の様な出力になっていて、それを3サイト分、csv形式で出力。あとはexcelにでも突っ込んで1分間ごとのアクセス数を色づけして眺めてみるのが良いのではないでしょうか。

.. code-block:: sh

   $ for h in `seq -w 0 23` 
   > do for m in `seq -w 0 59`
   > do echo $h:$m $(cat hoge-access.log | grep -c $h:$m) ; done ; done | \ 
   > tee -a hoge-access.min.log
   $ # などというファイルを三つくらい用意
   $ join hoge-access.min.log fuga-access.min.log | \
   > join - piyo-access.min.log | \ 
   > sed -e 's/ /,/g' > foo.csv



キャラクタ操作
================

tr
---
文字の変換と削除を行うコマンド。文字の置換の用途で使うことが多いです。

123という文字列を、3を4に、2を1に、1を6に変換します。 ``321`` という文字列を ``456`` という文字列に変換するわけではありません。

.. code-block:: sh
   
   $ echo 123 | tr 321 456
   654

ということは、テキストファイルの文字小文字変換もできます。いずれも同じ意味です [#tra]_ 。

.. [#tra] ファイル名を小文字にしたい？ mv のコマンドを作って実行すればいいのだ☆

.. code-block:: sh

   tr abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ
   tr a-z A-Z
   tr '[:lower:]' '[:upper:]'

trのtipsを調べると大体でてくるのは改行の削除なんですが。

.. code-block:: sh
   
   $ tr -d '\r' < dosfile.txt > unixfile.txt


expand
-------
タブを8つのスペースに変換します。おしまい [#expanda]_ 。

.. [#expanda] [練習問題] 同じことをsedあるいは他のコマンドで代用してみよう

unexpand
--------
スペースをタブに変換します。スペースが乱雑に現れてもなんとかしてくれそうです [#unexpand]_ 。

.. [#unexpand] [練習問題] 同じことをsedあるいは他のコマンドで代用してみよう


ファイルリスト表示
===================

ls
---
ディレクトリの中身を表示します。奥深いコマンドです [#ls-7sec]_ 。
さて問題です。 ``ls`` を単独で打ったときはどのような挙動をするでしょうか。おそらくこのような本を買っているということは、説明する必要がないのかなと思いつつ [#ls-alone]_ 。個人的によく打つオプションは、 ``ls -lhatr`` です。
オプションをさらっとおさらいしましょう。

.. [#ls-7sec] マニュアルでは7つのセクションに分かれています
.. [#ls-alone] 解説。カレントディレクトリの中身を表示します。ただし、ディレクトリの中身を再帰的に表示しません。また、 ``.`` から始まるファイルも表示しません。アルファベット順で表示します。リストの結果が端に到達したら縦方向に並べます。画面に出来ない文字は ``?`` で表示します


どんなファイルを表示するか
^^^^^^^^^^^^^^^^^^^^^^^^^^

-a
   ``.`` から始まるファイルも表示します

-A
  ``.`` から始まるファイルを表示しつつ、 ``.`` [#ls-Aa]_ , ``..`` [#ls-Aaa]_ は表示しません

.. [#ls-Aa] カレントディレクトリ
.. [#ls-Aaa] 一つ上のディレクトリ

-B
  ``~`` で終わるバックアップファイルを表示しません

-d
  ディレクトリのみを表示します [#ls-d]_ 

.. [#ls-d] lsしてたくさん普通のファイルがある中でディレクトリだけを表示したいときに使う

-I pattern
  $ ls -I '\*i\*' とすると、 ``i`` を含むファイルやディレクトリが表示されなくなります。

-R
  ディレクトリを再帰的に表示。下手すると大変なことになるので注意

どんな情報を表示するか
^^^^^^^^^^^^^^^^^^^^^^

--full-time
   フルなタイムを表示します。statでいいような...

-g
  ファイルのownerが省略され、groupのみを表示します

-G
  ファイルのownerを表示し、groupは表示しません。GNUでないバージョンのlsの互換性のためのオプション

-i
   inode番号を表示します [#inode]_ 

.. [#inode] inodeってなに？ググりましょう

-h
   無味乾燥な数字の羅列であるファイルのサイズを読みやすくしてくれます。ひゅーまんりりーだぶるのhです

-l
   ファイルのパーミッションやハードリンクの数、owner group、ファイルサイズ、タイムスタンプを表示します

.. tip:: ハードリンクの数
   
   ``-l`` を付けたときこんな感じで表示されます。kというファイルを作っておきます。
   
   .. code-block:: sh

      $ ls -l k                                                             
      2875312 -rw-r--r-- 1 nanaka nanaka 27 Nov 29 03:19 k

   このとき、nanakaの前の1ってのはなによ、という問題。こうすると分かります

   .. code-block:: sh
      
      $ ln k l # ハードリンクを張ります。同じinodeを指すファイルを作ります
      $ ls -l -i k l
      2875312 -rw-r--r-- 2 nanaka nanaka 27 Nov 29 03:19 k
      2875312 -rw-r--r-- 2 nanaka nanaka 27 Nov 29 03:19 l
      
      $ rm k # kファイルを消すと...?
      $ ls -l -i l                                                                 
      2875312 -rw-r--r-- 1 nanaka nanaka 27 Nov 29 03:19 l # 1 になった！


-n 
   ファイルのグループ、オーナーを数字で表示します [#ls-n]_ 

.. [#ls-n] see /etc/passwd

-o
   -Gとおなじ

-s
   ファイルに対するディスクの割当量を表示します [#ls-s]_ 

.. [#ls-s] 手元の環境だと、小さなファイルに関しては4 kbytes が割り当てられていました


ソート順を指定
^^^^^^^^^^^^^^^^^^^^^^^^

-c 
   ファイルが作られた(ctime)順でファイルを表示します

-f
   ソートせずそのまま表示します。-aが有効、-l, --color,-sが無効になっています

-r
   逆順にソート

-S
   ファイルの大きさ順にソートします。デフォルトは大きい順に並びます。小さい順に並べるなら、 ``-rS`` 。

-t 
   ファイルの更新時間(mtime)順にソートします

-u
   ファイルにアクセスした時間(atime)順にソートします

-U
   ファイルのソートを行いません。ファイルがたくさん入っているディレクトリで効果を発揮するでしょう

-v
   バージョンや番号順に表示します。1.2.3と1.2.10を意図したとおりに並べたいときにオススメ [#ls-v]_

.. [#ls-v] Coreutilsのセクション10.1.4にどのようにソートするのか書かれています

-X
   拡張子のアルファベット順で表示します。こんなオプション知らなかったぜ

表示のフォーマットを指定
^^^^^^^^^^^^^^^^^^^^^^^^

-1
   1ファイル1行で表示します。ファイルの一覧をファイルに書くときに使います

-C
   ファイルを縦方向に表示します。デフォルトの動作です

--color
   表示の際の色を決めます。--color=autoがaliasにあるのが普通 [#ls-colord]_ 。環境変数の LS_COLORS に色が定義されていますが、いつみても呪文だなあと思います

.. [#ls-colord] ディストリビューションによる？ なぜ疑問系？

-F
   ファイル名の一番最後にファイルタイプを示す1文字をひっつけます。/はディレクトリ、@はシンボリックリンク、>はソケットファイルなどなど


--file-type
   --Fぽいけど実行可能ファイルに関してはファイルタイプを示す1文字がつきません [#ls-ft]_

.. [#ls-ft] [問題] 実行可能ファイルのファイルタイプを表す1文字はなんでしょう

--indicater-style=word
   wordに、none,slash,file-type,classifyのいずれかを入れると、それぞれ、デフォルトの動作、-pオプション、--file-typeオプション、--Fオプションと同じ意味になります

-k
   1024バイト単位でブロックサイズを表示します。-hとか付けると効果がなくなります

-m
   ファイルをだらだらっとカンマ区切りで表示します

-p
   ディレクトリの後ろに/を付けます。そういえば、あなたのデフォルトのlsの動作はどうでしたっけ？ [#ls-p]_

.. [#ls-p] 読者をゆさぶる筆者の図。多分口元が緩んでいるかもしれないし、そういえば自分のlsの動作ってどうっだったっけ？と自分ではまっている

-x
   たくさんのファイルが入っているディレクトリを表示したとき、横方向にファイルをソートします。

-T cols
   横に並べるファイルの数を指定。 -T 1 にするとファイルの一覧が改行されずに1行で表示しようとするので画面が崩れること請け合い

-w cols
   横方向にどれだけ表示するか。-w 1とかすると-1と同じ効果 [#ls-w]_

.. [#ls-w] マニュアルには引数ないことになってるけど、実際は必要

タイムスタンプの表示形式
^^^^^^^^^^^^^^^^^^^^^^^^

--time-style=style
   タイムスタンプのフォーマットを指定できるよ！やったね！ [#ls-time-stamp]_

.. [#ls-time-stamp] ふえぇ、使いどこが分かりません！

ファイル名の表示形式
^^^^^^^^^^^^^^^^^^^^

-b 
   例を見てみましょう

   .. code-block:: sh
      
      $ touch Ctrl-v Enter # ctrl を押しながら
      $ # v を押しキーボードから手を離す
      $ # 一呼吸おいてEnterを押す。さらにもう一度Enter
      $ ls
      ?
      $ ls -b 
      \r

   ファイルの消し方は自分で考えてね！

-N
   ファイル名をクオートしません。危険が危ない

-q
   改行とか表示できない文字を?で表示。デフォルトの動作です

-Q
   ファイル名を""で囲みます

--show-control-chars
   表示できない文字もそのまま表示します。デフォルトの動作です




dir
---
``ls -C -b`` と同じ。

vdir
----
``ls -l -b`` と同じ

dircolors
---------
lsのカラー設定 [#dirc]_ 。呪文なので唱えて下さい。実行方法が特殊

.. [#dirc] ぶっちゃけた話、実機のコンソールに入ることは滅多にないのでsshクライアントで色を設定すればよくね？とは思っている。え？Mac?自分で何とかして下さい...

.. code-block:: sh
   
   $ eval "$(dircolors [option]... [file])"

-pオプションで設定を見ることが出来ます。


.. [#core-owarini1] 各セクションの分量的な意味で
.. [#core-owarini2] サンプルのコマンドは、実際に仕事で使っているものが多いです
.. [#core-warini3] 効果は個人差があります
.. [#hissya] [連絡先] https://twitter.com/tboffice または、 tbofficed@gmail.com まで
.. [#textbook] 教科書みたいだな


基本的操作
==========

cp
---
ファイルやディレクトリをコピーします。コピーするだけなら問題ないんですが...というところ。細かい仕様を把握しておかないと事故が起きるので [#cpa]_ 、もし本番環境でやるなら事前テストすることをおすすめします。とくに、 ``*`` や、末尾 ``/`` のあるなしで効果が変わります。
さて、もう少し細かい挙動を見て行きましょう。マニュアルいわく、デフォルトだとディレクトリーはコピーしないけど、-R,-a,-rオプションをつけると、ディレクトリもコピーするようになるよ、だそうです。シンボリックリンクからコピーするときは、そのシンボリックリンクしかコピーしないけど、--archive(--a),-d,--dereference(-L),--no-dereference(-P),-Hオプションがあるとデフォルトの設定を上書きしちゃうよ、とのこと。

オプションを解説します。

-a,--archive
  ファイルの属性と構造をそのままコピーします。というのも、デフォルトでは、コピーしたファイルは、コピーした時点のタイムスタンプになります。

-b,--backup[=method]
  バックアップオプションです。上書きや削除が発生する場合に使います。-bの場合は引数を取りません。

-d,--no-deference
  シンボリックリンクをコピーするとき、シンボリックをコピーします。ハードリンクの場合も同じくハードリンクとしてコピーします

-f,--force
  コピー先に同じファイルがあっても上書き...と思いきや実際の解説はこうなっています [#core-cp-f]_ 。コピー先の削除またはアンリンクするために、ファイルを開こうとします。それができない場合、削除とオープンを再度試します

-H
  コマンドで指定されたすべてのシンボリックリンクを辿ります

-i,--interactive
  インタラクティブです。ファイルを上書きするとき、上書きするかどうか聞きます。環境によっては、 ``alias cp -i`` されています。逆にうざかったりします

-l,--link
  ハードリンクをつくります。ディレクトリは指定出来ません

-L,--dereference
  シンボリックリンクをすべて辿り、それが指しているファイルやコピーを上書きします

-n,--no-clobber
  上書きしないオプションです。-nの前に-iオプションがあった場合は-iオプションを無効化します

-P,--no-dereference
  日本語のmanpage [#core-cp-P]_ と説明が食い違っているのは内緒にしておきましょう。原文では、シンボリックはシンボリックとしてコピーするとあります

-p,--preserve[=attribute_list]
  ファイルの属性を保ちつつコピーを行います。 ``-p`` オプションで、すべての属性を保ちます。ファイルのオーナー、タイムスタンプなどコピー時に変更しない属性(attribute_list)を選択できます。例えば、 ``cp --preserve=ownership,timestamp origin copyfile`` といった感じです。逆にこの属性は保存しなくてもいいや！というときに、 ``--no-preserve[=attribute_list]`` というオプションもあります。

-R,-r,--recursve
  ディレクトリを再帰的にコピーします。-Rであっても-rであっても効果は同じです

--reflink
  copy-on-write(COW)を使えるシステムであればCOWを使います。詳細はwikipediaで

-s,--symbolic-link
  ファイルに対してシンボリックリンクを作成します。ディレクトリのシンボリックリンクは作ることができません。 ``ln -s`` の威厳は保たれました。あ、あとシンボリックリンクをサポートしていないシステムでエラーが出るかも(・ω<)

-u,--update
  修正時刻がコピー元と同じかそれより新しい場合、コピーをしません

-v,--verbose
  verboseです

.. [#cpa] すでに存在するディレクトリの中に、コピーするディレクトリのファイルをぶちまけて混ざる事案や、シンボリックリンクを考慮するかしないか事案など
.. [#core-cp-f] 日本語manpageとcoreutilsを適当に混ぜあわせて解説を書いてます
.. [#core-cp-P] http://linuxjm.sourceforge.jp/html/gnumaniak/man1/cp.1.html 日本語ドキュメントでは、-Pと--parentが同じであると書かれていました。試してみたところ-Pオプションについては、原文が正しい模様。--parentオプションの説明としては合っていました

え？cpの速度が図りたいんですか？そんなときはpv(pipe viewer) [#pv]_ を使いましょう。yumのextra経由でインストールするか、公式サイトからRPMを落としてきてインストールします。

.. code-block:: sh
   
   $ pv  coreutils-8.22.tar.xz > hoge
   5.09MiB 0:00:00 [ 657MiB/s] [=====================================>] 100% 

.. [#pv] http://www.ivarch.com/programs/pv.shtml

dd
--
ファイルのコピーとか変換とか行います。ファイルと言っていますが、デバイスにも対応しています。よくあるディスクのコピーはこんな感じ

.. code-block:: sh
   
   # dd if=/dev/sda1 /dev/sdb1


「変換」はどこいったんじゃ！というツッコミもあるかと思いまして、例を挙げます。textというファイルを入力に使います。

.. code-block:: sh
   
   $ dd conv=ucase if=text of=test2

これでtextの中身のアルファベットが大文字になります！やったね！！ [#dd]_ 

.. [#dd] ucase以外にも、ebcdicやibmといったオプションもあります



install
-------
ファイルの属性を指定しつつファイルをコピーすることが出来ます。このコマンドを使うときが来たらmanを見ましょう。


mv
---
ファイルの移動を行います。副次的な作用としてファイルの名前を変えることが出来ます。cpのオプションと似ていますので、細かい説明は省略します。

rm
---
「あのころのきおくをけすにはどうやるです？」という妖精さんからの質問にはこう答えましょう。過去にだーくふれいむますたーであった頃の黒歴史を消去するコマンドです [#rm-k]_ 。

.. [#rm-k] 黒歴史をバージョン管理していたら別

前回 ``ls`` コマンドの説明の時に作った、改行コードがファイル名になっているファイルを消してみましょう。
 
.. code-block:: sh
   
   $ ls -b 
   \r
   $ rm Ctrl-v Enter # ctrl を押しながら v を押しキーボードから手を離す
   $ # 一呼吸おいてEnterを押す。さらにもう一度Enter


.. topic:: rm -rf /

   一般ユーザでスクリプトを実行したとき、空の変数$hogeを対象に ``rm -rf $hoge`` ってやってユーザディレクトリの中身を消すってことは、たまにあります。手動で実行する機会はめったにないとは思いたいところではありますが、不運にしてrootで ``rm -rf /`` を実行してしまった場合、どうなるかについて。
   突然シャットダウンするといったことはありません。/procディレクトリが残るようです [#core-rmrf]_ [#core-rmrf-ref]_ 。
   さて、突然の ``rm -rf /`` を防ぐにはどうするかというと、rmのaliasに ``--preserv-root`` をつけておきましょう。ついでに、safe-rmというソフトウエアがあります。これは、rmのラッパであり、システム的に消してはいけないディレクトリを消そうとするとメッセージが現れ消さずに済みます。

.. [#core-rmrf] 筆者も実際にVMware上で ``rm -rf /`` をやったことがあります。コマンドが実行できないだけでOS自体は起動している状態でした
.. [#core-rmrf-ref] 参考 http://katsu.watanabe.name/doc/rmrf/

.. topic:: rm undo

   いやー、気持ちは分かるんですけどね。わかりますよ。非常によくわかります。undoみたいなコマンドを打てば元通りにして欲しいですよね？大丈夫です。自分でコマンド作ってください。というのは半分冗談で、現実的な答えとしては、ゴミ箱を作ることです。ゴミ箱ディレクトリを作って、mvにエイリアスを貼ります。 ``alias rm='mv --target-directory=$HOME/.Trash'`` などとします。
   結論をいうと、バックアップ取れ！これに尽きます。

.. topic:: ext3grep
   
   ext3grepというツールがあります。ext3ファイルシステムから文字列をgrepしてくれます。公式ドキュメントいわく、「unmount the partition ASAP ; do not mount it again.」だそうです。ん？バイナリファイル復活させたい？がんばれ！


shred
------
爆ぜたり弾けたりしていた黒歴史を強力に清算するコマンドです [#core-chu2]_ 。ファイルやファイルシステム(/dev/sda3など)を引数にとり、何度も上書きを行って黒歴史を清算し、復元される可能性を減らします [#shred]_ 。

.. [#core-chu2] 劇場版でも爆ぜたり弾けたり。末永く爆発して欲しいですね（おっさん脳
.. [#shred] ただし、人々の記憶には残っているでしょう。物理破壊がより有効です（ハードディスクのことです


スペシャルファイルタイプ
========================
シンボリックリンクやFIFO、ディレクトリなどのファイルの操作を行います。


link
-----
linkシステムコールを経由してハードリンクをつくるコマンドです。


ln
---
ファイル間にリンクをつくるコマンドです。ファイルやディレクトリに対して、ハードリンクや、シンボリックリンク(-sオプション)を作ることができます。
一つ付け加えることとして、シンボリックリンクの上書きオプション(-f)があります。ディレクトリの場合、上書きできず、シンボリックリンクディレクトリの下にシンボリックリンクが出来ているというオチが待っています。

そのほかのオプションとしては、シンボリックリンクからハードリンクを作成するオプションというのがありましたが誰得感強いです。


mkdir
-----
ディレクトリを作ります。押さえておくべきオプションは二つ。パーミッションを指定する ``-m`` 、存在しない2階層以上のディレクトリを作る ``-p`` です [#mkdir]_ 。
なお、 ``-p`` オプションは、すでに存在するディレクトリを作ってもエラーにならないので、ディレクトリが存在するかどうか判定の判定を横着することができます。

.. [#mkdir] 自分がつくったディレクトリにchmod -x とかしちゃ駄目だぞ！おっちゃんとの約束だ！

mkfifo
------
名前付きパイプを作ります。パイプとは、 ``|`` です [#mkfifo]_ 。

.. [#mkfifo] これは名前なしパイプ(unnamed pipe)というらしい

具体例を示します。

.. code-block:: sh
   
   $ mkfifo pipe
   $ ls -l > pipe & ; cat < pipe

2行目のコマンドは、わざとワンライナーで書いていますが、別のセッションで試すと感動が増します。 ``;`` の前後のコマンドを逆にしても動作します [#mkfifo-cite]_ 。

.. [#mkfifo-cite] "Introduction to Named Pipes" http://www.linuxjournal.com/article/2156

mknod
------
FIFOや、キャラクタースペシャルファイル、ブロックスペシャルファイルを作ります。
キャラクタースペシャルファイルとは、キーボードやマウスなどの入力や出力を扱うファイルです。キャラクタースペシャルファイルは1バイトずつの読み出しですが、ブロックスペシャルファイルはある程度の塊としてデータを取り扱います。

下記、一番はじめの b がブロックスペシャルファイル、 c がキャラクタースペシャルファイルです。それぞれハードディスク、zeroです [#mknod-g]_ 。

.. code-block:: sh
   
   $ ls -l /dev/hda
   brw-rw---- 1 root disk 3, 0  May 22  2012 /dev/hda
   $ ls -l /dev/zero
   crw-rw-rw- 1 root root 1, 5  May 22  2012 /dev/zero 

.. [#mknod-g] なんかこう、目を合わせたら命令されそうですけど。zeroだけに原宿に戻せって。HAHAHA


readlink
---------
シンボリックリンクを引数に与えると、絶対パスを表示します。もしもつかうときがやってきたら使ってみて下さい。

rmdir
-----
空のディレクトリを削除します。 普段は ``rm -rf`` を使うところ。なお、 ``--ignore-fail-on-non-empty`` オプションをつけることによって、中身の入っているディレクトリでもエラーを返さず、削除もしません [#core-rmdir]_ 。

.. [#core-rmdir] 本書の執筆をサポートしてくれたmtgto氏によると、ホームディレクトリで、 ``rmdir --ignore-fail-on-non-empty .ssh`` を実行したところ、警告もなくコマンドが終わってしまって.sshディレクトリが消えてしまったと錯覚する事案が発生したとのこと。みなさんも気をつけましょう

unlink
------
システムが提供しているunlinkを使ってファイルを削除します。

ファイルの属性を変更
====================
chown
-----
ファイルのオーナーとグループを変更します。 ``--reference=filename`` でfilenameとそっくりのオーナーとグループになります。シンボリックリンクを追うかどうかのオプションもあり。ファイルのオーナーを変えるので基本的にroot(あるいはsudo)で操作。ちなみに、ownerとgroupのセパレータは ``:`` が一般ですが、筆者は ``.`` 派。

chgrp
-----
ファイルのグループを変更。こちらにも  ``--reference`` オプションがあります。

ご存知のように、 ``chown`` や ``chgrp`` は、変更するユーザ名やグループ名を引数に与えると指定したユーザ名やグループ名を変更することが出来ます。
uidとかgidで指定できたら、うれしくない？え？できちゃうの？出来ちゃうんですねこれが。uidやgidの数字の前に ``+`` を入れれば良いのです [#chgrp]_ 。

.. code-block:: sh
   
   # chown +1000.+1000 hoge-file
   # chgrp +$numeric_group_id fuga-file
   # chown +0:+0 /tmp/root-file

[#chgrp]_ Coreutilsのマニュアル2.6章に書いてあります。man引いても出てこないですね。ちなみに ``+`` はユーザ名やグループ名に使えません。実際に実行してみると「useradd: invalid user name 'hoge+'」だそうです。Solaris 10は例外。

chmod
-----
ファイルのパーミッションを変更します。set-group-IDとか使わないから忘れてしまったなぁ。

touch
-----
呼吸を止めて一秒なコマンドです [#touchk]_ 。ファイルのタイムスタンプを変更するコマンドです。オプションを使えば、ファイルのatime,mtimeを任意に変更することが出来ます。ただし、時間の指定の方法は覚えるしかないです [#touch]_ 。ここでも ``--reference`` オプションが使えます。

.. [#touchk] 違います
.. [#touch] dateコマンドの日付フォーマットとも違っていて若干もにょる
 

ディスク容量
============
原文曰く、ディスクは無限のデータ容量を保持できない、だそうです。確かに無限の容量があったら必要ありませんね。duくらいは残して欲しいところ。将来、dfコマンドをたたく必要がなくなる日は来るのか。

df
--
ディスクの空き容量を示します。よく使うオプションは、 ``df -h`` です。ディスクの使用量、空き容量がGBやTB単位で出ます。たまに使うオプションは、 ``df -i`` です。inodeの使用量を表示します。ファイルをフォーマットするときにinode数が足りるかどうか、心にとめておくといいことがあるかもしれません。そして、inode枯渇問題はしばしば深刻な問題を引き起こします。
ファイルシステムの形式(ext3やtmpfsなど)を表示するときは、 ``df -T`` とします。

du
--
カレントディレクトリにあるファイルのサイズをすべて表示します。 ``du -h`` さえ覚えていればなんとかなります。
個々のファイルサイズはいらないよ、というときはsummarizeオプションをつけて ``du -hs`` で所望の結果。筆者がよく使うコマンドは、 ``du -h /home/*`` して、誰が一番ディスクを使っているかランキングをとることです [#dua]_ 。

.. [#dua] さあここで ``sort`` の出番ですね

stat
-----
ファイルが作られた日時や編集された時間を表示するコマンド、と思いきや、ファイルのあらゆる属性を表示するコマンドです。と、思いきやほとんどlsで事足りるのでした。statでとれる属性は、割り当てられているブロックサイズやinode番号、atimeのエポックタイム数値などが取得できます。API的に取得するにはちょうどいいコマンドです。


sync
-----
メモリにバッファされているデータをディスクに書き込みます。サーバを ``shutdown`` する前に ``sync; sync; sync`` するという文化で年齢が分かるかもしれません。

truncate
--------
ファイルのサイズを減らしたり増やしたり。ボクと契約して10Mのダミーファイルを作ってよ！と言われても慌てず騒がず ``truncate -s 10M file`` して提出して下さい [#truncate]_ 。

.. [#truncate] [問題] 提出したデータの中身はどうなっているでしょうか


文字を表示
==========
文字列を表示するコマンドです。

echo
----
与えられた文字を標準出力に書き出します。デフォルトだと、最後に改行が入るので、ハッシュ値を作るときには注意して下さい。改行が入らないようにするためには、 ``-n`` オプションを。 ``\n`` (new line) といった特殊文字を出力するためには下記のように。

.. code-block:: sh
   
   $ echo -e "a\nb\nc"
   a
   b
   c


printf
------
C言語のprintfに似たフォーマットで文字列を出力します。たとえばこんな感じ

.. code-block:: sh
   
   $ printf "%d" "'a"
   97


yes
---
Ctrl-c(kill)が押されるまで、文字列を延々と表示します。最後はkillされる宿命なので、終了コードは必ず1になります。「イエッス、アスミス」はこのようにしてください

.. code-block:: sh
   
   $ yes asumisu

yesをインタラクティブに求めるコマンドの入力として使用することが…あまりありません。たとえば ``yes | rm -i files*`` 。


条件
====

false
-----
何もしない、成功しない。

.. code-block:: sh
   
   $ false 
   $ echo $? 
   1

true
----
何もしない、成功。シェルスクリプトのif文で、何もしないときに使います。そのときは、trueと同じ意味のビルトインコマンド ``:`` で代用することがあります。


test
----
コマンドの戻り値を判定して条件分岐します。コマンドとしては、 $ test ``expression`` や、ビルトインコマンドとして [ ``expression`` ] が利用できます。expressionについては、shellのマニュアルに書いてあります。指定されたファイルが存在するか、数値の大小比較などができます。

.. code-block:: sh
   
   $ HOGE=str
   $ if [ "xstr" = x$HOGE ] ; then echo $HOGE ; else ; \
   echo $HOGE is not str ; fi 
   str

HOGEという変数がstrかどうかを比較するサンプルです。もし、xがなくて、$HOGEが空だと ``[ str = ]`` となってしまい、syntax errorになるので慣習としてxを付けています。 ``[]`` の返値が1か0で条件分岐します。つまり、 ``[ "xstr" = x$HOGE ]`` というコマンドが実行可能です。

expr
----
式を評価します。といっても最近はもっぱら ``$()`` や ``$(())`` を使っています。例は、joinの時に出てきています [#core-join]_ 。括弧二つの方は何となく数値計算ができるので電卓代わりに使っています。 ``echo $((12*34))`` といった感じです [#core-expr]_ 。

.. [#core-join] 前号を参照してください
.. [#core-expr] そして始まる bc との宗教戦争

リダイレクション
================
シェルのリダイレクションです。コマンドとしては1個しかないとはこれいかに [#redi]_ 。

.. [#redi] ``|`` や ``>`` はシェル組み込みなので、しゃーなしだな

tee
----
出力を複数のファイルやプロセスに渡すコマンド。teeはTのことで、T型に出力という意味です [#teea]_ 。
コマンドの結果をファイルに書き込むときよく使うリダイレクション ``> file`` のとき、何が出力されるのか、別の端末を開いてtailするまで分かりません。ファイルにも書きつつ、標準出力にも出して欲しいとき使います。
実は前回の ``join`` のサンプルのところで出てきているのでサンプルはそちらを参考にして下さい。なお、 ``-a`` オプションはファイルへの追記を意味しています。

.. [#teea] Tの字形をみるとわかってくる

複数のファイルやプロセスに渡せるということなので、こんなコマンドも実行可能です。ファイルをダウンロードして標準出力に投げて、sha1sumとmd5sumでハッシュ値をとり、dvd.isoにダウンロードしたファイルを書き出し。

.. code-block:: sh
   
   wget -O - http://example.com/dvd.iso \
     | tee >(sha1sum > dvd.sha1) \
           >(md5sum > dvd.md5) \
     > dvd.iso


ファイル名の操作
================
ファイル名の操作をします。

basename
--------
ファイル名からディレクトリや拡張子を取り除きます。

.. code-block:: sh
   
   $ basename /usr/local/bin/sh  
   sh

スクリプトの中で、 ``basename $0`` と書くとそのスクリプト自身のファイル名が表示されます。ついでに、 ``basename $0 .sh`` と書くと、.shを除いたファイル名が表示されます。

dirname
-------
ファイル名やディレクトリパスを引数にとり、ファイル名の最後の一部を取り去ります。実際には、ファイルパスの最後のスラッシュを取り去る挙動をします。ファイルがあるかどうかのチェックはしていません。

.. code-block:: sh
   
   $ dirname /usr/local/bin/
   /usr/local/bin
   $ dirname /usr/local/bin/bash
   /usr/local/bin
   $ dirname /usr/local/bin/hoge
   /usr/local/bin # !?
   $ dirname /etc/etc/etc
   /etc/etc # うーん



pathchk
-------
ファイル名のSAN値をチェックします。正確には、ファイル名を引数にとって、ファイル名をほかのシステムに持って行っても大丈夫かどうかチェックします。意訳すると、こんな感じです:

* パーミッションがまずくてディレクトリの中身がみることができない
* ファイル名長すぎ

.. code-block:: sh
   
   $ pathchk a<snip>a
   pathchk: a<snip>a: File name too long


mktemp
------
一時的な空のファイルやディレクトリを作ります。bashスクリプトを書くときに、安全のため、使った方がいいけど、使わなくても何とかなります [#mktmpa]_ 。
既存のファイルを重複しないファイル名やディレクトリを作ってくれます。Xと書くと [#core-mktemp]_ その部分に適当な文字をあてがってくれます。

.. [#mktempa] 一時ファイルを作るときにmktmpを使っていると、ちゃんとしているなあという印象を与えることができます[脳内調べ]
.. [#core-mktemp] Xは3文字以上じゃないと怒られるので注意

実際に使うときは、こんな感じです。

.. code-block:: sh
   
   $ TMPFILE=$(mktemp hoge-XXXXXXX.txt)
   $ echo $TMPFILE
   hoge-82TiSmn.txt

その他オプションは下記の通り

-u XXX
  XXXの長さだけ、ある程度ランダムな文字を表示します

-d XXX
  ディレクトリを作ってくれます

-q
  ランダム文字を表示します。ファイルは作られません。ランダムな文字列がほしい時に使うといいんじゃないでしょうか

-p dir
  dirディレクトリの下にファイルを作ります

realpath
--------
相対パスやシンボリックリンクを絶対パスに直します。

.. code-block:: sh
   
   $ realpath /tmp/../tmp/../tmp
   /tmp


Working Context
================

働きましょう [#working]_ 。カレントディレクトリの状況を示します [#core-contexa]_ 。

.. [#working] ちっちゃくないそうである。
.. [#core-contexa] 某所の邦訳を見てみると「作業中の状況」となっており、まあ、だいたいあってる


pwd
---
「ここはどこ？」コマンドです。今いるディレクトリを表示します [#core-pwd]_ 。もうこれ以上説明しなくちゃダメカナ？ダメダヨ？

.. [#core-pwd] Print Working Directory

オプションは下記2種類。

-L
  --logicalと同じ。pwdのデフォルトの動作と覚えておけば不都合はなし

-P
  --physicalと同じ。シンボリックリンクをたどる。つまりこんな感じ

.. code-block:: sh
   
   [user@hostname]# ln -s /usr/local/apache2/logs /var/log/httpd # petatto symlink
   [user@hostname]$ cd /var/log/httpd
   [user@hostname /var/log/httpd% pwd -L
   /var/log/httpd
   [user@hostname /var/log/httpd% pwd -P
   /usr/local/apache2/logs


stty
----
端末のキャラクターを表示したり変更したりするコマンド。
役所に設置されている住民票発行装置や、銀行のATMを想像してみてください。とあるサーバの画面を離れたところにある画面に表示させているというイメージです。表示させて且つ操作することができます。パソコンに画面つなげて表示して操作するのも端末、sshでリモートログインしているときも端末 [#core-stty-tanmatsu]_ 。筆者はだいたいそんなイメージで端末という言葉を解釈しています。もっと年のいったおっさんが説明すると、もうちょっと古い端末を引っ張り出してきてボーとかテレタイプといった話をしだすと思います。

.. [#core-stty-tanmatsu] sshだとエミュレータになりますけどね。端末エミュレーターでぐぐると深い話が垣間見れるのではないでしょうか。ktermとかxtermとか

んでまあ、何が言いたいかというと、その端末の表示を変更するコマンドがこれなんです。
原文を読んでみましょう。ライン設定が与えられていないとき、sttyはボーレートを表示します。え？マジで？

.. code-block:: sh
   
   $ stty
   speed 38400 baud; line = 0;
   -brkint -imaxbel

baud(ボー)の登場です [#core-stty-baud]_ 。

.. [#core-stty-baud] ボーは、搬送波に対する1秒間あたりの変調の回数と定義される(wikipediaより)。そして、1baudは1pbsと一致するかもしれないし、しないかもしれない。詳しくはwikipeれ

中断しちゃいました。続きです。sttyはシステムがサポートしているライン制約ナンバーや ``stty sane`` で設定されている値から変更された設定を表示します。
デフォルトでは、モードを読み込みや設定は、端末上の標準出力で実行されます [#core-stty-p]_ 。--fileオプションで変更可能。

.. [#core-stty-p] よく考えなくても当たり前というかなんというか

sttyは引数ではないたくさんのオプションがあります [#core-stty-many]_

.. [#core-stty-many] 19.2.1から19.2.7まで解説に割かれています

主なオプションは下記です。

-a
  --allと同じです。実行してみましょう


.. code-block:: sh
   
   % stty -a 
   speed 38400 baud; rows 38; columns 79; line = 0;
   intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>;
   eol2 = <undef>; swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z;
   rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;
   -parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts -cdtrdsr
   -ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon
   -ixoff -iuclc -ixany -imaxbel -iutf8 opost -olcuc -ocrnl onlcr -onocr
   -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0 isig icanon iexten 
   echo echoe echok -echonl -noflsh -xcase -tostop -echoprt
   echoctl echoke

-F device
  --file=deviceと同じ。deviceに繋げます

-g
  --saveと同じ。ほかのsttyにつなぐため設定を保存しておくオプション

原文には、そのほかにオプションがたくさん載っているので、気になったら見てみましょう。

printenv
--------
環境変数を表示します。それだけです。

tty
----
スタンダートインプット上のターミナルのファイル名を表示します。打ってみましょう。

.. code-block:: sh
   
   % tty
   /dev/pts/0

上記の結果は、さくらのVPSサーバにログインして ``tty`` コマンドを打った結果です。さらに別の端末から同じサーバに入り、同じコマンドを打ってみましょう。

.. code-block:: sh
   
   % tty
   /dev/pts/12

通常ならば、1になります。ここのサーバでは、 ``screen`` が立ち上がっていて、1から11まで使っていました。つまり今回は、12に割り当てられました。詳しくはスペシャルデバイスファイルでぐぐってみましょう。


User Infomation
===============
ユーザやグループなどの情報を表示します。


id
--
ユーザのidを表示します。打ってみましょう [#core-id-a]_ 。

.. [#core-id-a] value-serverでの結果。16人目のユーザなのかもねー。ちなみに、本当に「hoge」というユーザでユーザ名を作りました

.. code-block:: sh
   
   $ id 
   uid=10016(hoge) gid=20000(hpusers) groups=20000(hpusers)

筆者がこのコマンドを使うときは、あのユーザwheelに入ってたっけ？と確認するときに使います。たとえばこのような感じ

.. code-block:: sh
   
   $ id ellen_jeager
   # 結果省略


なお、オプションは以下の通り

-g
  --groupと同じ。グループIDを表示します

-G
  --groupsと同じ。グループidと補助グループidを表示

-n
  --nameと同じ。ID番号じゃなくて名前で表示。-uか-g、または-Gが必須

-r
  --realと同じ。ID番号じゃなくてrealで表示。-uか-g、または-Gが必須。実行してみたけど、id番号しかでてこなかったぜ

-u
  --user と同じ。ユーザIDのみを表示

-z
  --contextと同じ。セキュリティーコンテキストを表示。SELinuxが無効になっていたら警告を表示してreturn 1する。

所属しているグループは、ログインした後に変更を加えても、今接続しているセッションには適用されないよ！ログインし直すと適用されるよ！と書いてあります [#core-id-hoge]_ 。

.. [#core-id-hoge] かなり意訳


logname
-------
現在のログイン名を表示します。utmpファイル [#core-logname-utemp]_ から情報を読み出します。このファイルは、システムの現在の状態のすべてのアカウント情報を管理していて、システムが起動してからの時間 [#core-logname-uptime]_ や、システムイベントやユーザのログイン、ログアウトの情報が記録されています。オプションは、 ``--help`` と ``--version`` のみです [#core-logname-ver]_ 。

.. [#core-logname-utemp] /var/run/utmp か /etc/utmp にあります
.. [#core-logname-uptime] uptimeコマンドを使って読み出します
.. [#core-logname-ver]  ``--version`` を打ってみたら、「Written by FIXME: unknown.」とでました

whoami
------
わたしはだあれ？コマンド。現在のユーザidに関連づけられているユーザ名を表示します。同じコマンドは、``id -un``。

groups
------
所属しているグループ名を表示します。打ってみましょう。引数にはユーザ名を入れます。

.. code-block:: sh
   
   $ groups hoge root
   hoge : hpusers
   root : root wheel rvm

``id -Gn`` と同じコマンドです。


users
-----
現在ログインしているユーザの名前を表示します。実行してみましょう。

.. code-block:: sh
   
   % users
   fairy fairy fairy fairy fairy fairy fairy fairy fairy fairy fairy fairy fairy fairy

妖精さんだらけーーー [#core-users-f]_ 。

.. [#core-users-f] はみ出してるし。本当は自分の名字が並んでいただけでした。それだとおもしろくないので妖精さんを並べてみました。英語表記これであってるのかしら。無難に yo-say-san とかにしておいた方がよかったかも？生足魅惑のマーメイド？？つまり上半身は魚？？？妖精さんの上半身は魚…ッ　ざわ・・・ざわ・・・


who
---
現在ログオンしているユーザの情報を表示します。コマンドの例は下記です。

.. code-block:: sh
   
   who [option] [file] [am i]

原文をよく見ると、「am i」だけ斜体になってないんですよね。ということで実行してみましょう

.. code-block:: sh
   
   % who am i
   chiba    pts/11       2013-06-23 17:57 (:pts/12:S.10)

だいたい実行結果が見えてきたところで、オプションです。

-a
  --allや ``-b -d --login -p -r -t -T -u`` と同じです

-b 
  --bootと同じです。システムが最後に起動した日時を表示します。uptimeだと起動してからの時間が表示されます。意外と便利かも

.. code-block:: sh
   
   % who -b
   system boot  2012-12-14 05:16

-H
  --headingと同じです。表示の際にヘッダをつけます

-l
  --loginと同じです。訳すのが面倒だったので実際に打つとこんな感じです [#core-who-l]_ 

.. [#core-who-l] value-serverで試していてうすうす気づいていたのですが、これ、物理コンソールにrootでログインしっぱなしになってないですかね

.. code-block:: sh
   
   $ who -l
   LOGIN    tty4         May 14 14:01              5500 id=4
   LOGIN    tty2         May 14 14:01              5481 id=2
   LOGIN    tty3         May 14 14:01              5491 id=3
   LOGIN    tty1         May 14 14:01              5472 id=1
   LOGIN    /dev/ttyS1   May 27 19:30             48033 id=v/tt
   LOGIN    tty5         May 14 14:01              5503 id=5
   LOGIN    tty6         May 14 14:01              5514 id=6

--lookup
   utempに記録されているホスト名からDNSルックアップしようとします。デフォルトでは機能しません。インターネットアクセスをするので表示するまでにちょっと時間がかかるからです。

-m
  ``who am i`` と同じです [#core-who-m]_ 。

.. [#core-who-m] エイリアス張る意味あるの？＼つまんねー事聞くなよ！／


System Context
==============
システムの情報を変えたり表示したりします。

date
----
役割は大きく分けて2種類あります。時刻を表示することと、時刻を設定することです。時刻の表示から説明すると思った？残念、時刻の設定でした！ [#core-date-zannnenn]_。

.. [#core-date-zannnenn] 残念さやかちゃん

時刻の設定。よく忘れます::

  date [-u|--utc|--universal] [ MMDDhhmm[[CC]YY][.ss] ]

``-u`` は使う機会はないでしょう [#core-date-u]_ 。6月25日の23時34分45秒に設定したいときはこのように [#core-date-set]_ 

.. [#core-date-u] amazon awsだと引っかかりそうな。と思ったけど、日にちずれてることもないから、どうでもよかった
.. [#core-date-set] 正確な時間がズレまくっていると、ntpdでも合わせてくれないので、だいたい近い日時に合わせましょう。ただし、時間を巻き戻す場合は、アプリケーションで不整合が起きることがあるので要注意。本番環境で気軽にやるなよ!!!

.. code-block:: sh

   $ date 06252334.45

時刻の設定はこのへんにして、単独で実行してみます。

.. code-block:: sh
   
   $ date
   Mon Jun 24 00:34:47 JST 2013

表示形式を変更したり、1ヶ月後といった相対的な日付も出力することができます。オプションをいちいち説明するよりは実例を見たほうが早いです [#core-date-a]_

.. [#core-date-a] 完全に執筆してる時期ばれてますやん

.. code-block:: sh

   $ date +%Y%m%d
   20130624
   $ date '+%Y-%m-%d %H:%M:%S'
   2013-06-24 00:45:11
   % date -d '1 hours ago' +%X                                                                                
   23時20分22秒 # 日本語ロケールの場合こうなる 

基本的な書き方はこれでマスターです。例えば、%Yと書くと今年の西暦である2013を表示、%yで西暦の下二桁、つまり、13を表示します。
気をつけるところは、%が出現する一番最初に「+」の記号をつけること。さもないと、エラーになります。
%に続く文字については、manを見ましょう [#core-date-man]_ 。
次に、-d(または--date)オプションの説明をします。-dには、1時間前や1時間後、明日や先月などを指定することができます。「last month」と書けば、現在の時刻を基準とした先月の日時を表示することができます。適当に書いても結構柔軟に対応してくれます。ついでに指定できる文字列は、first,second,...,twelth,last,this,first,next,tommorow,yesterdayなどです。さて、この後は「21.1.7 Examples of date」を追っていきます。

.. [#core-date-man] %Y%m%d %H%M%Sあたりを覚えておけば、たいてい事足ります

date --date='2 days ago'
  おとといの日付を指定します

date --date='3 months 1 day'
  3ヶ月と1日後の日付を指定します

date --date='25 Dec' +%j
  1月1日から指定日までの日数を表示します

date '%B %-d'
  月の完全名と月を表示します。%Bの部分はロケールによってJulyとか7月などに変わります。%-dの部分は、0埋めをしません。7月6日であれば、6となります。%dだけだと06になります

date --set='+2 minutes'
  現在のシステムの時刻を2分進めます。root権限が必要です。システムの時刻を変更するときは注意だぞ！

date +%s
  1970年1月1日からの秒を表示します [#core-date-epoch]_ 

.. [#core-date-epoch] 俗にいうエポックタイム。-dで日付を指定すればその時点のエポックタイムを表示します

date -d @946684800                                                                                              
  1970年1月1日から経過した秒数を理解しやすい感じで表示してくれます [#core-date-epoch2]_ 

.. [#core-date-epoch2] Coreutils 5.3.0から機能です。これ以前だと、 -d '1970-01-01 UTC 946684800 seconds'とする


ここで問題です。先月の最終日の日にちを出すワンライナーを作ってください。例えば、3月なら「31」を表示します。
ここで答えを書いてしまうとすぐ見えてしまうので、この本の最後らへんの脚注に載せました。

.. topic:: dateとcrontab

   crontabに ``date +%Y%m%d`` と書くと正しく動作しません。 ``%`` をエスケープしないといけないんだよ、な、なんだってーΩ ΩΩ。実際にその罠に陥っている人に遭遇したことがあります。 ``date +\%Y\%m\%d`` と書きましょう。これで動く！


.. topic:: 時刻合わせ

   サーバの製造元が日本でない場合、現地時間に合わせてあったりします。このとき、OSのisoイメージからマウントして、サーバにOSをインストールすると、BIOSの時刻を引っ張ってくるので時刻がズレます。そういえば、BIOSであわせるの忘れてた(・ω<)となります。仕方ないので最近はこのようにしてます。当たり前ですけど、時刻がずれている場合は、OSをインストールしたらすぐ時刻をあわせましょう。

   .. cpde-block:: sh
      
      # ntpdate <ntp server name OR IP> && hwclock --systohc && hwclock --adjust


arch
----
``uname -m`` と同じ。実行してみましょう [#core-arch-a]_ 。

.. code-block:: sh

   $ arch
   x86_64
   $ uname -m  
   x86_64


.. [#core-arch-a] $ strace archしてみたら、uname呼んでました

nproc
-----
有効なプロセッサの数を表示します。実行してみましょう [#core-nproc]_ [#core-nproc-a]_。

.. code-block:: sh

   $ nproc
   32

.. [#core-nproc] value-serverでの実行結果。こんなサーバなかなかお目にかかれないなぁ。/proc/cpuoinfo見てみたら、本当にCPUが32個あった
.. [#core-nproc-a] ついでに、このコマンドはcoreutils 8.4あたりの比較的新しいバージョンに入っているみたいです。CentOSの5あたりだと入ってないかも

uname
-----
現代語訳すると「coreutilsの作りしコマンドよ、我が前にシステム情報を表示せ、uname」になるんですかね [#core-uname-a]_ 。実行してみましょう [#core-uname-b]_ 。

.. [#core-uname-a] その前に、現代語訳じゃないでしょ。アニメ始まったの1999年だから15年くらい前だぜ。今思うと十分に中二病ですな、このセリフ
.. [#core-uname-b] 本当は1行で出力されます

.. code-block:: sh

   $ uname -a 
   Linux e2.valueserver.jp 2.6.32-358.6.1.el6.x86_64 
   #1 SMP Tue Apr 23 19:29:00 UTC 2013 x86_64 x86_64 x86_64 GNU/Linux

オプションは下記の通り。

-a
  すべての情報を表示。32bitか64bitが分からなかったらその部分は表示しないよ！

-i
  ハードウエアのプラットフォームの名前(x86_64とか)を表示。カーネルによって情報が作られていないときは ``unknown`` って表示します

-m
  ハードウエアの名前を表示(x86_64とか)

-n
  ネットワークノードのホスト名を表示(e2.valueserver.jp)

-p
  命令セットアーキテクチャとかISAと呼ばれるプロセッサの型を表示。 ``unknown`` だったらオプションの ``-i`` と同じ理由

-o
  OSの名前を表示(GNU/Linux)

-r
  カーネルリリースを表示(2.6.32-358.6.1.el6.x86_64)

-v
  カーネルバージョンを表示(#1 SMP Tue Apr 23 19:29:00 UTC 2013)



hostname
--------
コマンド単体で実行するとホスト名を表示します。ホスト名を変更する場合は、rootユーザで、引数に新しいホスト名を指定して実行します。一旦ログアウトしてログインすると、ホスト名が変更されています。再起動して元に戻ってしまうのを防ぐために、設定ファイルの変更も忘れずに [#core-hostname]_ 。

.. [#core-hostname] hostsファイルも気にしてあげてください

hostid
------
ホスト識別子を16進数で表示します。ホスト識別子ってなんやねん、という人がググってください [#core-hostid]_ 。

.. [#core-hostid] つまり、筆者もよくわかってない

uptime
------
現在の時間とシステムが起動してからの時間と、ログインユーザの数と、ロードアベレージを表示します。ロードアベレージは、1,5,15分の平均値です。

.. code-block:: sh

   $ uptime 
   00:29:45 up 44 days, 10:29,  2 users,  load average: 0.62, 0.69, 0.62

SELinuxコンテキスト
===================

SELinux(Security-Enhanced Linux)の設定を行います。rootに権限が集中することを防ぐシステムの構築を提供します [#core-selinux]_ 。

.. [#core-selinux] wikipediaを参考にしました。ちゃんと知りたい方は調べてください(続きは英語で)

chcon
-----
選択されたファイルのSELinuxセキュリティーコンテキストを変更します。

オプションは下記の通り

--dereference
  シンボリックリンクに影響せず、シンボリックリンク先のファイルに影響します。デフォルトの動作です。

-h
  シンボリックリンクのみに影響します

--reference=rfile
  rfileと同じ設定になります

-R
  再帰的な感じで動作します

-v
  すべてのファイルについて調べて表示します

-u user
  セキュリティーコンテキストをユーザ userに設定します

-r role
  セキュリティーコンテキストをロール roleに設定します

-t type
  セキュリティーコンテキストをタイプ typeに設定します

-l range
  セキュリティーコンテキストをレンジ rangeに設定します

runcon
------
特殊なSELinuxのコンテキスト上でコマンドを実行します。オプションです。

.. code-block:: sh

   runcon context command [args]
   runcon [options] command [args]

-c
  変更する前にプロセス変更コンテキストを計算する [#core-runcon-c]_ 

-u,-r,-t,-l
  chcon のオプションと同じ

.. [#core-runcon-c] Compute process transition context before modifying の訳。ムズイ


変更コマンド
============
いろいろ変更しまっせ。

chroot
------
特定のルートディレクトリでコマンドを実行します。スーパーユーザでのみ実行できます [#cpre-chroot-a]_ 。何がうれしいの？というと、本来ならば、/ディレクトリからのツリー構造になっているものを、任意のディレクトリ(/tmp/chroot/など)を/と再定義したツリー構造に変更することができます。つまり、本来の/は見えなくなります。ソフトウエアのテストなどを行うときに使います [#core-chroot-a]_ 。

.. [#cpre-chroot-a] 例外あり

実行はこんな感じ。

.. code-block:: sh

   chroot option newroot [ command [args] ... ]
   chroot option

.. [#core-chroot-a] 原文に書いてある例を実行してみたんですがうまく動かず。本来だったら/直下の必要なファイルを任意のディレクトリにコピーして実行するものらしい

env
---
環境変数を表示したり、一時的に環境を変数を変更してコマンドを実行します。 ``env`` 単体で実行すると、設定されている環境変数が表示されます。
一時的に環境変数を変更するときの例。/tmp/binにHOGEと出力される実行可能なhogeファイルをおいておきます。

.. code-block:: sh

   env PATH="$PATH:/tmp/bin" hoge
   HOGE

オプションは下記の通りです

-O,--null
  出力時に改行しません [#core-env-O]_ 

.. [#core-env-O] 新しめのバージョンに入っているオプションらしい

-u ``name``
  nameという環境変数を削除します

-,-i,--ignore-environment
  環境変数をすっからかんにして実行します。さっきのコマンドをアレンジしてみましょう。

.. code-block:: sh

   env # まずは実行して様子見
   env - PATH="$PATH:/tmp/bin" env

なんとなく実行結果はつかめましたか？

nice
----
いいね！コマンドです [#core-nice-iine]_ 。nicenessを変更してプログラムを実行します。nicenessって何？いい質問ですね [#core-nice-iine2]_ 。nicenessは、システムで実行されるプロセスがいくつかあってその中でどれくらい有利に実行されるかを決める値です [#core-nice-affects]_ 。

.. [#core-nice-iine] 正しくはlike
.. [#core-nice-iine2] いいね！（言いたいだけだろ!!
.. [#core-nice-affects] 厳密には違うけど適当な説明ならこれでおっけー！（こらこら

単体で実行すると、現在のnice値が表示されます。-20 **(優先度高)** から19 **(優先度低)** までの値をとります。そしてnicenessはスケジュールの優先度と混同してはいけません。アプリケーションを実行する順序を決めます。nicenessはスケジューラーに単に忠告するだけで、無視することもあります(そして原文ではhistrical practiceに脱線)。

実行例から。数値を与えればそれだけnice値が下がります。

.. code-block:: sh

   $ nice
   0 # current nice 
   $ nice nice
   10
   $ nice -n 19 nice
   19
   $ nice --10 nice
   nice: cannnot set niceness: Permission denied

niceをつけてコマンドを実行すると、nice値が10になります。 ``-n`` をつけると数値を指定できます。 ``-`` のあとに数値をつけると ``-n 数値`` と同じ効果です。 ``--10`` はマイナス値にしようとしています。マイナス値をつけることはnicenessをあげることになります。nicenessをマイナス値にするためには、root権限が必要です。

.. code-block:: sh

   $ sudo nice -n -20 nice
   -20

ちなみに、reniceで実行中のプロセスのnice値を変更することができます。

nohup
-----
ログアウトしても実行したコマンドを実行し続けることができるコマンドです。

.. code-block:: sh
   
   $ nohup yes asumisu &
   $ logout

これで、いつでもイエッスアスミスし放題ですね [#nohupa]_ 。

.. [#nohupa] ついでにディスク食い尽くしてプロセスが落ちるところまでがオチです(ﾄﾞﾔｧ

hungupシグナルを無視して、引数のコマンドを実行します。ログアウトしたあとでも引き続き実行されます。
標準入力がターミナルのとき、/dev/nullからリダイレクトされます。ターミナルのセッションはコマンドによって使われるターミナルと誤って見なさないようにするためです [#core-nohup-unknown]_。これはGNU拡張で、GNUでないシステムでは、 ``nohup command [arg] ... </dev/null`` として下さい。

.. [#core-nohup-unknown] これを書いている筆者もよくわかってない

標準出力がターミナルのとき、コマンドの標準出力はnohup.outファイルに追記されます [#nohupb]_ 。

.. [#nohupb] そのファイルに書けない場合は、$HOME/hohup.outに書き、そこもだめだった場合はコマンドは実行されません。nohup.outファイルは、コマンドを実行しているユーザだけが書き込みができ、且つ読み込みができる権限で作られます。umaskを無視します

標準エラーがターミナルのとき、標準出力に出ます。標準出力が閉じられているときは、上記のnohup.outファイルに追記されます。

例を見ましょう

.. code-block:: sh

   $ nohup make > make.log

ちゃんとバックグラウンドで実行するには、イエッスアスミスで出てきたように、コマンドの最後に ``&`` を置きましょう。もし、niceコマンドを使いたいときは、 ``nohup nice command`` としてください。


stdbuf
------
比較的最近追加されたコマンド。説明が難しいので、原文直訳気味です。

i/oストリームバッファリングを変更してコマンドを実行します。stdbufは、プログラムに関連づけられた3つの標準I/Oストリーム(標準出力、標準入力、標準エラー出力)のバッファリング動作を1つに変更できます。オプションはもちろん3つ、

-i mode, --input=mode
  標準入力ストリーミングバッファリングを調整します

-o mode, --output=mode
  標準出力ストリーミングバッファリングを調整します

-e mode, --error=mode
  標準エラーストリーミングバッファリングを調整します

modeに指定する文字は下記です

L
  ストリームを行単位でバッファします。このモードでは、新しい行が出力されるか、入力がターミナルデバイスに接続されたストリームから読まれるまで結合します。このオプションは標準入力では使えません。

0
  大文字のoではなく、ゼロです。選択されたストリームのバッファリングを無効にします。このモードでは、データはただちに出力され、要求されたデータの分だけが入力から読み込まれます。入力と出力のための機能の違いに注意してください。入力のバッファリングを無効にすると、応答性やストリーム入力機能のブロッキング動作に影響を与えません。基本的には、要求されたよりも少ないデータを読み取る場合でも、たとえば関数freadの場合はまだ、EOFかエラーになるまでブロックします [#core-stdbuf-0]_ 。

size
  完全バッファモードにおいて、バッファのサイズを明確にします。サイズは整数のあとにKB(1000 KiloBytes)とかK(1024KibiBytes)をつけることができます

.. code-block:: sh

   tail -f access.log | stdbuf -oL cut -d ' ' -f1 | uniq 

このコマンドでは access.log の一意なエントリがあると直ちに出力されます [#core-stdbuf-ex]_ 。

.. code-block:: sh

   command | stdbuf -oL gawk '{print strftime("[%a %b %e %H:%M:%S %Z %Y] "), $0; }'

コマンドの標準出力にタイムスタンプを追加する例 [#stdbufa]_ 。このコマンドの具体的な活用例はあまりないので、エントリを各チャンスですよ！プロデューサーさん!!


.. [#core-stdbuf-0] google翻訳を借りました。以前見た時よりも翻訳が自然になっていて驚き。そして翻訳された日本語の文章の意味はイマイチ把握できず
.. [#core-stdbuf-ex] 日本語マニュアルからお借りしました
.. [#stdbufa] http://qiita.com/yyamamot/items/60a0a007b0016da61b32


timeout
-------
タイムリミットを設定してコマンドを実行します [#core-timeout]_ 。

.. [#core-timeout] 比較的新しいCoreutilsのバージョンに入っている模様。Cent5には入っておらず、Cent6あたりで使えました

.. code-block:: sh

   timeout [option] duration command [arg] ...

オプションは下記の通り

--preserve-status
  タイムアウトを示す具体的な終了ステータスを返します。どのくらいかかるかわからないコマンドを実行するときに便利 [#core-timeout-miss]_ 

--foreground
  正常フォアグラウンドTTYを使用できるように、独立したバックグラウンドプログラムループを作成しません。これは、コマンドが2つの状況で、対話型シェルから直接起動していないコマンドがタイムアウトをサポートするために必要とされます。2つの状況とは、
  1. commandがインタラクティブで、例えば端末から読み取る必要がある場合
  2. 端末からコマンドを直接送信したい場合、たとえばCtrl-Cなど

-k duration, --kill-after=duration
  監視コマンドは、指定した期間のあとに、KILLシグナルを送ることによってkillされていることを確認します。選択された信号が致命的でないと証明された場合、このオプションを指定しない場合、コマンドをkillすることはありません。

-s signal, --signal=signal
  デフォルトであるTERMシグナルではなく、タイムアウトの時にsignalをコマンドに送ります。signalはHUPや数値で指定します

期間に関しては、小数の後に、s(秒、デフォルト)、分であるm、時間h、日dをとることができます。期間が0の場合、タイムアウトになりません。実質のタイムアウトの期間はシステムの状態に依存します。特に注意しないといけないのは、1秒以内のタイムアウトです。

イエッスアスミスに細工します [#timeout-saiku]_ 。

.. code-block:: sh

   $ timeout 5 nohup yes asumisu $

5秒後に実行が終わるので、ディスクにも安心。

.. [#core-timeout-miss] 原文にはスペルミスがあるので訳すときは注意。余談ですけど、managed commandってなんて訳したらいいんでしょうね
.. [#core-timeout-foreground] コマンドが2つの状況ってなんでしょうね。バックグラウンドとフォアグラウンドのこと?おしえてエロい人!
.. [#timeout-saiku] この言い方が適切かどうかは不明


プロセスコントロール
====================

この章にはkillしかありません。

kill
----
非実在の妖精さん(プロセス)にお菓子(シグナル)を与えます [#core-kill]_ 。お菓子(シグナル)にもいろいろあって、それを食べた妖精さん(プロセス)は、消えてみたり、いっぺん寝て起きてみたり、「どうされましたか？」 [#core-kill-NUL]_ などと言ってみたりします。お菓子によってどのような行動をするかは、妖精さんごとに定義されています。

killコマンドのデフォルトでは、TERMというお菓子を妖精さんに与えます [#core-kill-term]_  。
お菓子(シグナル)には、番号や名前がついています。HUP(番号だと1) [#core-kill-HUP]_ 、KILL(番号だと9)  [#core-kill-KILL]_ などです。詳細は、Coreutilsのマニュアル、2.5 Signal specificationsに載っています [#core-kill-signal]_ 。なお、アクセス権限のある妖精さんにしか効果ありませんのでご注意を。

.. [#core-kill-NUL] null signalのイメージ(多分ちょっと違う)
.. [#core-kill] ググってみるとプロセスを強制終了するコマンドという説明を見かけます。これは、正確ではありません
.. [#core-kill-HUP] ログをローテートさせるときに使います。apacheのlogrogateであれば
.. [#core-kill-KILL] プロセスを終了させるときに使います。通常「殺す」って言います。なお、このシグナルは、受け取り拒否または無視できません
.. [#core-kill-term] システムコールの世界にようこそ
.. [#core-kill-signal] あのシグナルなんだっけ？というときは、 `` $ man 7 signal`` してください

よくあるコマンドを示します。「-9」というお菓子を、妖精さん番号「12345」(プロセスID/PID)に与えます。2つのコマンドとも同じ意味です。

.. code-block:: sh

   $ kill -9 12345
   $ kill -KILL 12345

妖精さん番号が正の数の時、0の時、-1の時、-1より小さい時の説明があります。気になる人は自分で調べてみてください。なお、 ``killall`` というコマンドがあります。これは、引数にプロセス名を取ります。rootで単に ``killall`` を実行すると、すべてのプロセスが終了します(UNIX System Vバージョンの場合) [#core-killall]_ 。

.. [#core-killall] このへんはwikipediaあたりを参照しました


遅延
====
Delayingです。

sleep
-----
指定された時間だけ休憩します。アラームとか実行するといいんじゃないでしょうか。

.. code-block:: sh

   $ sleep 1d 1h 1m 1s && echo $'\a'

1日+1時間+1分+1秒後にビープ音を鳴らします [#core-sleep-pi]_ 。もちろん、このコマンドを実行するマシンは足元にないとだめですよ [#core-sleep-beep]_ [#core-sleep-beep2]_ 。

.. [#core-sleep-pi] 筆者の部屋に転がってたfreeBSDの入った実機で echo $'\a' を実行してみたら「ピッ」って鳴った
.. [#core-sleep-beep] クラウド上のサーバがピーピーなっちゃいますよ（ホントかなぁ
.. [#core-sleep-beep2] value-serverで大量に実行してみたけど怒られなかったし、いいんじゃないでしょうか。そもそも一般ユーザで鳴るのかね？まあいいか

数値操作
========

factor
------
「せんせい！そいんすうぶんかいがしたいです」「よろしい、ならば戦争（ry」「おいやめろ！！」ということがないように、素因数分解ができるコマンドがあります。

.. code-block:: sh

   $ factor 60
   60: 2 2 3 5

原文だと唐突に、メルセンヌ素数をもとに実行例が出てきます。曰く、8番目と9番目のメルセンヌ素数 [#core-factor-m]_ を計算するときには、Athlonの2.2GHzのCPUで30ミリ秒くらいかかります [#core-factor-Mersenne]_　 、とあります。

.. code-block:: sh

   M8=$(echo 2^31-1|bc)
   M9=$(echo 2^61-1|bc)
   n=$(echo "$M8 * $M9" | bc)
   /usr/bin/time -f %U factor $n
   4951760154835678088235319297: 2147483647 2305843009213693951
   0.03

さらに読んでいきましょう。8番目のフェルマー数 [#core-factor-Fermat]_ (2^256+1)は20秒くらいかかります [#core-factor-itu]_ 。

.. [#core-factor-m] 2^n-1(nは自然数)の形の自然数且つ素数。ちなみに48番目が発見された日は、2013年1月、って最近じゃないか。物好きな方はGIMPSでググると吉
.. [#core-factor-Mersenne] さくらのサーバでやってみたら桁数多すぎで怒られました。velue-serverでやってみたら、0.02でした
.. [#core-factor-Fermat] フェルマー数とは、2^2^n+1(nは自然数)
.. [#core-factor-itu] この文章書かれたのいつなんでしょうね？

大きい数になると一般的に求めるのが難しくなります。比較的小さい数字を求めるときに、ポラード・ロー因数分解法が使われます。でかい数で且つ素因数がおっきい数を求めるときは、もっとほかの方法をとった方がよさげです。

GNU MP [#core-factor-gmp]_ を使わずにビルドされたfactorコマンドは、single-precision算術が有効になります。その算術方法は、小さい数字を計算することが得意で、2^64以上の数字はサポートしていません。

.. [#core-factor-gmp] GMPといって、多倍長演算ライブラリのことです。http://gmplib.org を参照

seq
---
連続した数字を表示します。使う頻度はそこそこ多いかもしれないです [#core-seq-bash]_ 。実行例はこんな感じ。

.. [#core-seq-bash] bashのカッコ展開で代用することもおおいかも。{1..100}とか

.. code-block:: sh

   $ seq 3
   1
   2
   3
   $ seq -w 7 10
   07
   08
   09
   10
   $ seq 1 2 5
   1
   3
   5
   $ seq -w 10 -2 2
   10
   08
   06
   04
   02
   $ seq -s "," 10 -2 2
   10,8,6,4,2
   $ seq -s + 1 100 | bc
   5050

オプションに関しては察してください。あとは-fオプションでprintfと同じようなフォーマットが使えるモードがあります。あとは非常に大きい数字の場合、5e+06といったような表現になるときがあります。そんなときは、-fを使ってフォーマットを指定して解決。

.. code-block:: sh

   $ seq  1000000 1000000 10000000
   1e+06
   2e+06
   3e+06
   4e+06
   5e+06
   6e+06
   7e+06
   8e+06
   9e+06
   1e+07
   $ seq -f "%.0f" 1000000 1000000 10000000
   1000000
   2000000
   3000000
   4000000
   5000000
   6000000
   7000000
   8000000
   9000000
   10000000


おわりに
--------
26章まで駆け抜けて参りましたcoreutils。実は、この後も続きます。ファイルのパーミッションの説明やdateコマンドの書式やチュートリアルなどが書かれています。

前月の最終日の日にちを表示するコマンドです。こちらです [#core-last-monthofaday]_ [#core-motto]_ 。

.. [#core-last-monthofaday] $ date -d $(date +%Y%m01)'-1day' +%Y%m%d ちょっとずるい感じもしますがこうするしかなかった（諦め
.. [#core-motto] もっと短くかける方、いますぐ筆者までリプライください

最後に、このコマンドを俺が一番うまく使えるんだ！という Tips をお持ちの方、この環境だとこの辺でこけるといった検証報告をお持ちの方、この説明違うよ!全然違うよ!!ということを思われた方は、筆者 [#hissya]_ まで連絡を頂けると大変ありがたいです。


Let's enjoy coreutils life.

